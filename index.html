<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <title>Ghost Scene</title>

  <!-- İsteğe bağlı: biraz daha havalı font için -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&family=Manrope:wght@300;400;500&display=swap" rel="stylesheet">

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      background: #000;
      font-family: "Manrope", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5ff;
      overflow: hidden;
    }

    audio {
      display: none;
    }

    /* --- GİRİŞ EKRANI YAZI STİLLERİ --- */
    .ghost-label {
      font-size: 12px;
      letter-spacing: 0.22em;
      text-transform: uppercase;
      color: rgba(195, 195, 255, 0.85);
      font-weight: 400;
      opacity: 0.9;
    }

    .ghost-title {
      font-family: "Cinzel Decorative", "Manrope", system-ui, serif;
      font-size: 24px;
      font-weight: 600;
      letter-spacing: 0.04em;
      margin-top: 4px;
      margin-bottom: 4px;
      background: linear-gradient(130deg, #ffffff, #b7a7ff, #ff8ad6);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow:
        0 0 8px rgba(170, 150, 255, 0.9),
        0 0 14px rgba(0, 0, 0, 0.9);
      animation: ghostGlow 3.2s ease-in-out infinite alternate;
    }

    .ghost-tagline {
  font-size: 12px;
  font-weight: 600; /* ==> yazıyı kalınlaştırdık */
  color: rgba(210, 210, 255, 0.9);
  line-height: 1.5;

  text-shadow:
    0 0 4px rgba(140,130,255,0.35),
    0 0 8px rgba(70,60,140,0.25);

  animation: ghostFade 6s ease-in-out infinite;
}


    @keyframes ghostGlow {
      0% {
        text-shadow:
          0 0 4px rgba(168, 148, 255, 0.6),
          0 0 12px rgba(255, 138, 214, 0.45);
        transform: translateY(0px);
      }
      100% {
        text-shadow:
          0 0 12px rgba(220, 210, 255, 1),
          0 0 22px rgba(255, 138, 214, 0.9);
        transform: translateY(-1px);
      }
    }

    @keyframes ghostFade {
      0% {
        opacity: 0.75;
      }
      50% {
        opacity: 1;
      }
      100% {
        opacity: 0.7;
      }
    }
  </style>
</head>
<body>
  <!-- Gizli arka plan sesi -->
  <audio id="bg-audio" src="sounds/arkas.mp3" loop preload="auto"></audio>

  <div id="root"></div>

  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/build/three.min.js"></script>

  <script>
    // --------- SES: SADECE GİR / ENTER İLE BAŞLAT ---------
    function startAudio() {
      const audio = document.getElementById("bg-audio");
      if (!audio) return;

      audio.play().catch(err => {
        console.log("Ses başlatılamadı:", err);
      });
    }
    // document click listener YOK artık
    // --------------------------------------------------

    const { useEffect, useRef, useState } = React;
    const THREE = window.THREE;

    function GhostScene() {
      const containerRef = useRef(null);
      const [name, setName] = useState("");
      const [showOverlay, setShowOverlay] = useState(true);

      useEffect(() => {
        if (!containerRef.current) return;

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x111111, 0.08);

        const camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 3.5;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x0a0a0a);
        renderer.domElement.style.position = "absolute";
        renderer.domElement.style.top = "0";
        renderer.domElement.style.left = "0";
        renderer.domElement.style.width = "100%";
        renderer.domElement.style.height = "100%";

        containerRef.current.appendChild(renderer.domElement);

        // ---------- GHOST SHADER ----------
        const ghostVertexShader = `
          uniform float time;
          varying vec2 vUv;
          varying vec3 vNormal;
          varying vec3 vPosition;
          
          void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            
            vec3 pos = position;
            float wave = sin(pos.y * 3.0 + time * 2.0) * 0.1;
            pos.x += wave * 0.3;
            pos.z += cos(pos.y * 2.0 + time * 1.5) * 0.1;
            
            vPosition = pos;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `;

        const ghostFragmentShader = `
          uniform float time;
          uniform vec3 ghostColor;
          varying vec2 vUv;
          varying vec3 vNormal;
          varying vec3 vPosition;
          
          void main() {
            vec3 viewDir = normalize(cameraPosition - vPosition);
            float fresnel = pow(1.0 - max(dot(viewDir, vNormal), 0.0), 3.0);
            
            float pulse = sin(time * 2.0) * 0.2 + 0.8;
            float glow = fresnel * pulse;
            
            float noise = fract(sin(dot(vUv * 10.0 + time * 0.5, vec2(12.9898, 78.233))) * 43758.5453);
            glow += noise * 0.1;
            
            float fadeBottom = smoothstep(-1.5, 0.5, vPosition.y);
            float alpha = (glow * 0.6 + 0.2) * fadeBottom;
            
            vec3 color = ghostColor * (1.0 + glow * 0.5);
            
            gl_FragColor = vec4(color, alpha * 0.7);
          }
        `;

        const ghostMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            ghostColor: { value: new THREE.Color(0.4, 0.4, 0.6) }
          },
          vertexShader: ghostVertexShader,
          fragmentShader: ghostFragmentShader,
          transparent: true,
          side: THREE.DoubleSide,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });

        const ghostGeometry = new THREE.SphereGeometry(1, 32, 32);
        ghostGeometry.scale(1, 1.5, 1);
        const ghost = new THREE.Mesh(ghostGeometry, ghostMaterial);
        ghost.position.y = 0.5;
        ghost.scale.set(1.5, 1.5, 1.5);
        scene.add(ghost);
        // -----------------------------------

        // ---------- EYES ----------
        const eyeVertexShader = `
          uniform float time;
          varying vec2 vUv;
          
          void main() {
            vUv = uv;
            vec3 pos = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `;

        const eyeFragmentShader = `
          uniform float time;
          varying vec2 vUv;
          
          void main() {
            vec2 center = vUv - vec2(0.5);
            float dist = length(center);
            
            float outerGlow = smoothstep(0.5, 0.2, dist);
            float pupil = smoothstep(0.15, 0.12, dist);
            
            float blink = step(0.5, sin(time * 0.3) * 0.5 + 0.5);
            float blinkMask = smoothstep(0.2, 0.5, abs(vUv.y - 0.5));
            
            float alpha = outerGlow * (1.0 - pupil * 0.7) * mix(blinkMask, 1.0, blink);
            
            vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(0.4, 0.4, 0.6), outerGlow);
            
            gl_FragColor = vec4(color, alpha * 0.9);
          }
        `;

        const eyeMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 }
          },
          vertexShader: eyeVertexShader,
          fragmentShader: eyeFragmentShader,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });

        const eyeGeometry = new THREE.PlaneGeometry(0.3, 0.3);
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(-0.25, 0.3, 0.95);
        ghost.add(leftEye);

        const rightEye = new THREE.Mesh(eyeGeometry.clone(), eyeMaterial.clone());
        rightEye.material.uniforms.time = { value: 0 };
        rightEye.position.set(0.25, 0.3, 0.95);
        ghost.add(rightEye);
        // -----------------------------------

        // ---------- RAIN ----------
        const rainVertexShader = `
          attribute float speed;
          attribute float offset;
          uniform float time;
          varying float vAlpha;
          
          void main() {
            vec3 pos = position;
            float t = mod(time * speed + offset, 10.0);
            pos.y = 10.0 - t;
            
            vAlpha = smoothstep(0.0, 1.0, t) * smoothstep(10.0, 8.0, t);
            
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = 2.0;
            gl_Position = projectionMatrix * mvPosition;
          }
        `;

        const rainFragmentShader = `
          varying float vAlpha;
          
          void main() {
            vec2 center = gl_PointCoord - vec2(0.5);
            float dist = length(center);
            if (dist > 0.5) discard;
            
            gl_FragColor = vec4(0.7, 0.8, 0.9, vAlpha * 0.6);
          }
        `;

        const rainCount = 2000;
        const rainGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(rainCount * 3);
        const speeds = new Float32Array(rainCount);
        const offsets = new Float32Array(rainCount);

        for (let i = 0; i < rainCount; i++) {
          positions[i * 3] = (Math.random() - 0.5) * 20;
          positions[i * 3 + 1] = Math.random() * 10;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 20;
          speeds[i] = Math.random() * 2 + 3;
          offsets[i] = Math.random() * 10;
        }

        rainGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        rainGeometry.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));
        rainGeometry.setAttribute('offset', new THREE.BufferAttribute(offsets, 1));

        const rainMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 }
          },
          vertexShader: rainVertexShader,
          fragmentShader: rainFragmentShader,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });

        const rain = new THREE.Points(rainGeometry, rainMaterial);
        scene.add(rain);
        // -----------------------------------

        // ---------- FOG ----------
        const fogGeometry = new THREE.BufferGeometry();
        const fogCount = 300;
        const fogPositions = new Float32Array(fogCount * 3);
        const fogSizes = new Float32Array(fogCount);

        for (let i = 0; i < fogCount; i++) {
          const radius = Math.pow(Math.random(), 0.6) * 12.0;
          const theta = Math.random() * Math.PI * 2.0;
          const phi = Math.acos(2.0 * Math.random() - 1.0);
          
          fogPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
          fogPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta) * 0.6;
          fogPositions[i * 3 + 2] = radius * Math.cos(phi);
          
          fogSizes[i] = Math.random() * 1.5 + 0.5;
        }

        fogGeometry.setAttribute('position', new THREE.BufferAttribute(fogPositions, 3));
        fogGeometry.setAttribute('size', new THREE.BufferAttribute(fogSizes, 1));

        const fogVertexShader = `
          attribute float size;
          varying float vDepth;
          
          void main() {
            vDepth = (modelViewMatrix * vec4(position, 1.0)).z;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `;

        const fogFragmentShader = `
          varying float vDepth;
          
          void main() {
            vec2 center = gl_PointCoord - vec2(0.5);
            float dist = length(center);
            
            float alpha = smoothstep(0.5, 0.0, dist);
            float depthFade = smoothstep(-15.0, -5.0, vDepth);
            
            gl_FragColor = vec4(0.3, 0.3, 0.35, alpha * 0.15 * depthFade);
          }
        `;

        const fogMaterial = new THREE.ShaderMaterial({
          vertexShader: fogVertexShader,
          fragmentShader: fogFragmentShader,
          transparent: true,
          blending: THREE.NormalBlending,
          depthWrite: false
        });

        const fog = new THREE.Points(fogGeometry, fogMaterial);
        scene.add(fog);
        // -----------------------------------

        // LIGHTS
        const ambientLight = new THREE.AmbientLight(0x222244, 0.5);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xff8844, 1.5, 10);
        pointLight.position.set(0, 1, 2);
        scene.add(pointLight);

        let time = 0;

        const animate = () => {
          requestAnimationFrame(animate);
          time += 0.016;

          ghostMaterial.uniforms.time.value = time;
          rainMaterial.uniforms.time.value = time;
          eyeMaterial.uniforms.time.value = time;
          rightEye.material.uniforms.time.value = time;

          ghost.position.y = 0.5 + Math.sin(time * 0.8) * 0.3;
          ghost.rotation.y = Math.sin(time * 0.3) * 0.2;

          fog.rotation.y += 0.0005;

          camera.position.x = Math.sin(time * 0.1) * 0.5;
          camera.lookAt(ghost.position);

          renderer.render(scene, camera);
        };

        animate();

        const handleResize = () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        };

        window.addEventListener('resize', handleResize);

        return () => {
          window.removeEventListener('resize', handleResize);
          if (containerRef.current && renderer.domElement.parentNode === containerRef.current) {
            containerRef.current.removeChild(renderer.domElement);
          }
          renderer.dispose();
          ghostGeometry.dispose();
          ghostMaterial.dispose();
          rainGeometry.dispose();
          rainMaterial.dispose();
          fogGeometry.dispose();
          fogMaterial.dispose();
        };
      }, []);

      function handleEnter() {
        if (name.trim().length === 0) return;
        startAudio();          // GİR / Enter ile müzik başlar
        setShowOverlay(false); // giriş ekranı kaybolur
      }

      function handleKeyDown(e) {
        if (e.key === "Enter") {
          handleEnter();
        }
      }

      return React.createElement(
        "div",
        {
          ref: containerRef,
          style: {
            position: "relative",
            width: "100vw",
            height: "100vh",
            overflow: "hidden"
          }
        },
        showOverlay &&
          React.createElement(
            "div",
            {
              style: {
                position: "absolute",
                inset: 0,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                background: "radial-gradient(circle at top, rgba(40,40,80,0.7), rgba(3,0,10,0.96))",
                backdropFilter: "blur(7px)",
                WebkitBackdropFilter: "blur(7px)",
                zIndex: 10
              }
            },
            React.createElement(
              "div",
              {
                style: {
                  padding: "22px 26px",
                  minWidth: "260px",
                  maxWidth: "320px",
                  background: "rgba(5, 3, 20, 0.92)",
                  borderRadius: "18px",
                  border: "1px solid rgba(130, 120, 255, 0.55)",
                  boxShadow:
                    "0 0 25px rgba(120,110,255,0.6), 0 0 80px rgba(0,0,0,1)",
                  display: "flex",
                  flexDirection: "column",
                  gap: "10px",
                  textAlign: "center"
                }
              },
              React.createElement(
                "div",
                { className: "ghost-label" },
                ""
              ),
              React.createElement(
                "div",
                { className: "ghost-title" },
                "İsmini yaz"
              ),
              React.createElement(
                "p",
                { className: "ghost-tagline" },
                "Karanlık bile seni görünce ürperiyor"
              ),
              React.createElement(
                "div",
                {
                  style: {
                    display: "flex",
                    gap: "8px",
                    marginTop: "6px"
                  }
                },
                React.createElement("input", {
                  type: "text",
                  value: name,
                  onChange: e => setName(e.target.value),
                  onKeyDown: handleKeyDown,
                  placeholder: "İsmin...",
                  style: {
                    flex: 1,
                    padding: "8px 10px",
                    borderRadius: "999px",
                    border: "1px solid rgba(150,140,255,0.8)",
                    background: "rgba(10, 7, 35, 0.97)",
                    color: "#f5f5ff",
                    fontSize: "13px",
                    outline: "none",
                    boxShadow: "0 0 12px rgba(130,120,255,0.65) inset"
                  }
                }),
                React.createElement(
                  "button",
                  {
                    onClick: handleEnter,
                    style: {
                      border: "none",
                      outline: "none",
                      padding: "8px 14px",
                      borderRadius: "999px",
                      fontSize: "12px",
                      fontWeight: 500,
                      cursor: "pointer",
                      background:
                        "linear-gradient(135deg, #8c7bff, #ff6ec7)",
                      color: "#050310",
                      boxShadow:
                        "0 0 14px rgba(255,110,199,0.9), 0 0 26px rgba(140,123,255,0.9)",
                      whiteSpace: "nowrap"
                    }
                  },
                  "GİR"
                )
              )
            )
          )
      );
    }

    try {
      const container = document.getElementById("root");
      const root = ReactDOM.createRoot(container);
      root.render(React.createElement(GhostScene));
    } catch (err) {
      console.error("Mount error:", err);
    }
  </script>
</body>
</html>

